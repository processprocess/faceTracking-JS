<!DOCTYPE html>
<html lang="en">
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>FaceTrackerTest</title>

		<style>
      html, body { margin: 0; padding: 0; overflow: hidden; font-family: inconsolata;}

      /*#canvasForTracker {
        position : absolute;
        left : 0;
        top : 0;
      }*/

      h2 {
        /*text-align: center;*/
        /*float: right;*/
        position: absolute;
        top:0;
        bottom: 0;
        left: 0;
        right: 0;
        margin: auto;
      }

      #content {
        text-align: center;
        margin: 0, auto;
        padding: 0;
        overflow: hidden;
        /*float: left; */
        /*position: absolute;*/
      }

      #video{
        /*width:100px;
        height:100px;*/
        opacity: .04;
        position: absolute;
        top:0;
        bottom: 0;
        left: 0;
        right: 0;

        /*margin: auto;*/
      }

      #testingDiv{
        font-size: 100px;
        color:red;
        /*width:200px;
        height:200px;*/
        opacity: .04;
        background-color: red;
        /*position: absolute;*/
        /*top:0;
        bottom: 0;
        left: 0;
        right: 0;*/

        /*margin: auto;*/
      }

      #canvasForThree {
          /*background-color: blue;*/
          /*opacity:1;*/
          /*width: 360px;
          height: 200px;*/
          /*border: 1px solid black;*/
          /*margin: 100px;*/
          /*padding: 0px;*/
          /*position: fixed; /* fixed or static */*/
          /*top: 100px;*/
          /*left: 100px;*/
      }

		</style>
	</head>

	<body>
		<script src="./libs/utils.js"></script>
		<script src="./libs/clmtrackr.js"></script>
		<script src="./libs/model_pca_20_svm.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js"></script>
    <script src="https://threejs.org/build/three.min.js"> </script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
      <h2>FACE_LAB</h2>

        <video id="video" width="360" height="200" autoplay="" loop=""></video>
        <!-- <video id="video" width="360" height="200" autoplay="" loop=""></video> -->

        <!-- 175 125
        368 288 -->

        <div id="canvasForThree"></div>

      <!-- </div> -->

      <script>

				let videoInput = document.getElementById('video');

        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;

        if (navigator.getUserMedia) {
            navigator.getUserMedia({video: true}, handleVideo, videoError);
        }

        function handleVideo(stream) {
            video.src = window.URL.createObjectURL(stream);
        }

        function videoError(e) {
            console.log('there was an error');
        }

        let ctracker = new clm.tracker();
        ctracker.init(pModel);
        ctracker.start(videoInput);

        //

        let scene, renderer, camera;

        let triangleMesh;
        let squareMesh;

        let faceLine;

        let chinLine;
        let rightEyeBrowLine;

        // let cubeMesh;
        let cubeMeshArray = [];

        // let bottomLipGeometry;
        // let topLipGeometry;
        // let noseGeometry;
        // let noseLineGeometry;
        // let leftEyeGeometry;
        // let rightEyeGeometry;
        // let leftEyeBrowGeometry;

        begin();
        animate();

        function begin(){
          camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
          camera.position.z = 200;

          scene = new THREE.Scene();

          let light = new THREE.PointLight(0xffffff);
          light.position.set( -100, 200, 100 );
          scene.add( light );

          let threeContainer = document.getElementById( 'canvasForThree' );
          // threeContainer.innerHTML = 'test';

          renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setPixelRatio( window.devicePixelRatio );
          renderer.setSize( window.innerWidth, window.innerHeight );
          threeContainer.appendChild( renderer.domElement );
          renderer.setClearColor( 0xFFFFFF, 1);
          // renderer.setClearColor( 0x333F47, 0.4);



          // videoInput.width = renderer.domElement.clientWidth;
          // videoInput.width = 230;
          // videoInput.height = renderer.domElement.clientHeight;
          // videoInput.height = 300;

          controls = new THREE.OrbitControls( camera, renderer.domElement );
          controls.enablePan = true;
          controls.enableZoom = true;
          controls.enableRotate = true;
          controls.enableDamping = true;

          window.addEventListener( 'resize', onWindowResize, false );

          // let lineMaterial = new THREE.LineBasicMaterial({
          // 	color: 0x0000ff
          // });
          //
          // let chinGeometry = new THREE.Geometry();
          // for (let i = 0; i<15; i++) {
          //   chinGeometry.vertices.push(
          //   	new THREE.Vector3( 0, 0, 0 )
          //   );
          // }
          // chinLine = new THREE.Line( chinGeometry, lineMaterial );
          // scene.add( chinLine );

          let cubeGeometry = new THREE.BoxGeometry(2,2,2);

          let cubeMaterial = new THREE.MeshLambertMaterial({
            color: 0x0000FF
          });

          let faceContainerGeometry = new THREE.BoxGeometry(2,2,2);
          let faceContainerMaterial = new THREE.MeshLambertMaterial({
            color: 0xFF0000
          });
          let faceContainerMesh = new THREE.Mesh( faceContainerGeometry, faceContainerMaterial );

          for (var i = 0; i < 71; i++) {
  					let cubeMesh = new THREE.Mesh( cubeGeometry, cubeMaterial );
  					cubeMeshArray.push( cubeMesh );
            faceContainerMesh.add( cubeMesh );
            // scene.add( cubeMesh );
  				}
          faceContainerMesh.position.set(0, 0, 0);
          scene.add( faceContainerMesh );

        }


        // console.log(cubeMeshArray[1].position);

        function getPositions(){
          let positions = ctracker.getCurrentPosition();
          smoothOutAnimation(positions)
          console.log(positions);
        }

        // function smoothOutAnimation (positions) {
        //   // console.log(positions);
        //   for (let i = 0; i < cubeMeshArray.length; i++) {
        //     new TWEEN.Tween( cubeMeshArray[i].position ).to( {
        //       x: ((positions[i][0] * 2 / renderer.domElement.clientHeight ) * 2 - 1) * 100,
        //       y: ((positions[i][1] * 2 / renderer.domElement.clientWidth ) * 2 - 1) * -100,
        //       z: 0 },
        //       3000 )
        //     .easing(TWEEN.Easing.Exponential.Out)
        //     .start()
        //     .onComplete(function(){
        //     getPositions()
        //     return;
        //     // console.log('test')
        //     });
        //   }
        // }




        // for (var i = 0; i < cubeMeshArray.length; i++) {
        //   cubeMeshArray[i].position.x = ((positions[i][0] * 2 / renderer.domElement.clientHeight ) * 2 - 1) * 100;
        //   cubeMeshArray[i].position.y = ((positions[i][1] * 2 / renderer.domElement.clientWidth ) * 2 - 1) * -100;
        // }

        // function testingCallbal () {
        //   for (var i = 0; i < cubeMeshArray.length; i++) {
        //     let positions[i][0]
        //     if(!positions[i][0]){
        //       // console.log('bigger');
        //       return;
        //     }else{
        //       cubeMeshArray[i].position.x = ((positions[i][0] * 2 / renderer.domElement.clientWidth ) * 2 - 1) * 100; //width
        //       cubeMeshArray[i].position.y = ((positions[i][1] * 2 / renderer.domElement.clientHeight ) * 2 - 1) * -100; //x and y
        //     }
        //   }
        //
        // }



        function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth, window.innerHeight );
        }


        function animate() {
          // console.log(video.width);
          requestAnimationFrame( animate );
          TWEEN.update();

          let positions = ctracker.getCurrentPosition();
          // console.log(window.innerWidth);
          // console.log(renderer.domElement.clientWidth);

          // use tween JS for current position
          // when animation is complete, it asks for new position
          // move getCurrentPosition into tween.js function.
          // console.log(positions[1][1]);
          for (var i = 0; i < cubeMeshArray.length; i++) {

              cubeMeshArray[i].position.x = positions[i][0] -175 ;
              // cubeMeshArray[i].position.x = ((positions[i][0] * 2 / window.innerWidth ) * 2 - 1) * 100; //width
              // cubeMeshArray[i].position.x = ((positions[i][0]*100 / window.innerWidth )); //width
              // cubeMeshArray[i].position.x = ((window.innerWidth * 2 / positions[i][0] ) * 2 - 1) * 100; //width
              // cubeMeshArray[i].position.x = positions[i][0] / window.innerWidth ; //width
              // cubeMeshArray[i].position.x = positions[i][0] * (video.width); //width
              // cubeMeshArray[i].position.x = positions[i][0] * 2 / (window.innerWidth/10); //width
              // cubeMeshArray[i].position.x = positions[i][0]; //width
              // cubeMeshArray[i].position.x = positions[i][0] / window.innerHeight //width
              // console.log(videoInput.width);
              cubeMeshArray[i].position.y = -( positions[i][1] -125 ) ;
              // cubeMeshArray[i].position.y = -( window.innerHeight / positions[i][1] + (positions[i][1]/2) ) ;
              // cubeMeshArray[i].position.x = ((positions[i][0] * 2 / window.innerWidth ) * 2 - 1) * 100; //width
              // cubeMeshArray[i].position.y = ((positions[i][1] * 2 / window.innerHeight ) * 2 - 1) * -100; //Height
              // cubeMeshArray[i].position.y = (-positions[i][1] / (window.innerWidth/10)) * 100
              // cubeMeshArray[i].position.y = -positions[i][1] * 2 / window.innerHeight //Height
              // cubeMeshArray[i].position.y = positions[i][1];
  				}


          // for (let p = 0; p < 17; p++) {
          //   if(p < 15){
          //     chinLine.geometry.vertices[ p ].x = positions[p][0];
          //     chinLine.geometry.vertices[ p ].y = positions[p][1];
          //   }
          //   if(p > 15){
          //     // rightEyeBrowLine.geometry.vertices[ p ].x = positions[p][0];
          //     // rightEyeBrowLine.geometry.vertices[ p ].y = positions[p][1];
          //   }
          //   // if(p > 15){
          // }
          // chinLine.geometry.verticesNeedUpdate = true;
          // rightEyeBrowLine.geometry.verticesNeedUpdate = true;
          //
          // // geometry.attributes.position.needsUpdate = true; // use this for buffer geometry

          // cc.clearRect(0, 0, canvasInput.width, canvasInput.height);
          // ctracker.draw( canvasInput );

          controls.update();
          renderer.render( scene, camera );

        }
        // smoothOutAnimation();
      </script>

		</div>
    <canvas width="11px" height="781px" id="renderCanvas" style="display:none;"></canvas>

    <!-- center feed on screen so that it overlaps canvas -->
    <!-- get position only every other frame -->

    <!-- put face inside container -->
    <!-- face only scales when window width is changed -->



</body>
</html>