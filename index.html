<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>FaceTrackerTest</title>
    <link rel="stylesheet" href="styles/styles.css" media="screen" title="no title">
    <script src="./libs/utils.js"></script>
    <script src="./libs/clmtrackr.js"></script>
    <script src="./libs/model_pca_20_svm.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js"></script>
    <script src="https://threejs.org/build/three.min.js"> </script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
	</head>
	<body>
      <h2>FACE_LAB</h2>

        <video id="video" width="368" height="288" autoplay="" loop=""></video>
        <div id="canvasForThree"></div>

      <script>

				let videoInput = document.getElementById('video');

        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;

        if (navigator.getUserMedia) {
          navigator.getUserMedia({video: true}, handleVideo, videoError);
        }

        function handleVideo(stream) {
          video.src = window.URL.createObjectURL(stream);
        }

        function videoError(e) {
          console.log('there was an error');
        }

        let ctracker = new clm.tracker();
        ctracker.init(pModel);
        ctracker.start(videoInput);

        //
        let cubeMeshArray = [];

        let scene, renderer, camera;

        let lineMesh;

        let numberContextArray = [];
        let numberMeshArray = [];
        let numberTextureArray = [];

        let triangleMesh;

        //

        begin();
        animate();

        //

        function begin(){

          camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
          camera.position.z = 200;

          scene = new THREE.Scene();

          let light = new THREE.PointLight(0xffffff);
          light.position.set( -100, 200, 100 );
          scene.add( light );

          let threeContainer = document.getElementById( 'canvasForThree' );

          renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setPixelRatio( window.devicePixelRatio );
          renderer.setSize( window.innerWidth, window.innerHeight );
          threeContainer.appendChild( renderer.domElement );
          renderer.setClearColor( 0xFFFFFF, 1);
          // renderer.setClearColor( 0x333F47, 0.4);

          controls = new THREE.OrbitControls( camera, renderer.domElement );
          controls.enablePan = true;
          controls.enableZoom = true;
          controls.enableRotate = true;
          controls.enableDamping = true;

          window.addEventListener( 'resize', onWindowResize, false );

          //

          let faceContainerGeometry = new THREE.BoxGeometry(2,2,2);
          let faceContainerMaterial = new THREE.MeshLambertMaterial({
            color: 0xFF0000
          });
          let faceContainerMesh = new THREE.Mesh( faceContainerGeometry, faceContainerMaterial );

          let cubeGeometry = new THREE.BoxGeometry(2,2,2);
          let cubeMaterial = new THREE.MeshLambertMaterial({
            color: 0x0000FF
          });

          for (let i = 0; i < 71; i++) {
  					let cubeMesh = new THREE.Mesh( cubeGeometry, cubeMaterial );
            cubeMeshArray.push( cubeMesh );
            faceContainerMesh.add( cubeMesh );
  				}
          faceContainerMesh.position.set(0, 0, 0);
          scene.add( faceContainerMesh );

          //

          // let lineGeometry = new THREE.Geometry();
          //
          // let lineMaterial = new THREE.LineBasicMaterial({
          //   color: 0x0000ff
          // });
          //
          // lineMesh = new THREE.Line( lineGeometry, lineMaterial );
          // scene.add( lineMesh );

          //

          for(let i = 0; i<71; i++){
            let numberCanvas = document.createElement('canvas');
            numberCanvas.width = 256;
            numberCanvas.height = 128;
            let numberContext = numberCanvas.getContext('2d');
            numberContext.font = "90px Arial";
            numberContextArray.push( numberContext )

            let numberTexture = new THREE.Texture(numberCanvas)
            numberTexture.width = 10;
            numberTexture.height = 128;
            numberTextureArray.push( numberTexture )

            let textMaterial = new THREE.MeshBasicMaterial({ map: numberTexture });
            textMaterial.transparent = true;

            let mesh1 = new THREE.Mesh(
                new THREE.PlaneGeometry(10, 5),
                textMaterial
              );
            numberMeshArray.push( mesh1 )
            scene.add( mesh1 )
          }

          //

          let triangleGeometry = new THREE.Geometry();
          triangleGeometry.vertices.push(new THREE.Vector3( 0.0, 10.0, 0.0 ));
          triangleGeometry.vertices.push(new THREE.Vector3( -10.0, -10.0, 0.0 ));
          triangleGeometry.vertices.push(new THREE.Vector3( 10.0, -10.0, 0.0 ));
          triangleGeometry.faces.push(new THREE.Face3( 0, 1, 2 ));

          let triangleMaterial = new THREE.MeshBasicMaterial({
            color: 0x0000FF,
            // vertexColors: THREE.VertexColors,
            side: THREE.DoubleSide,
            wireframe: true
          });

          triangleMesh = new THREE.Mesh( triangleGeometry, triangleMaterial );
          scene.add( triangleMesh );

          //

        }


        //

        function animate() {

          //

          let positions = ctracker.getCurrentPosition();
          requestAnimationFrame( animate );

          //

          triangleMesh.geometry.vertices[0].set(-(positions[35][0] -185), -(positions[35][1] -155), -5);
          triangleMesh.geometry.vertices[1].set(-(positions[44][0] -185), -(positions[44][1] -155), -5);
          triangleMesh.geometry.vertices[2].set(-(positions[2][0] -185), -(positions[2][1] -155), -5);
          triangleMesh.geometry.verticesNeedUpdate = true;
          triangleMesh.geometry.dynamic = true;
          triangleMesh.geometry.__dirtyVertices = true;

          //

          // for(let i = 0; i < 40; i++) {
          //   if(i%2 === 0) {
          //     lineMesh.geometry.vertices[i] = {x: -(positions[0][0] -185), y: -(positions[0][1] -155), z: 0};;
          //   } else {
          //     lineMesh.geometry.vertices[i] = {x: -(positions[i][0] -185), y: -(positions[i][1] -155), z: 0};
          //   }
          // }
          // lineMesh.geometry.verticesNeedUpdate = true;
          // lineMesh.geometry.__dirtyVertices = true;

          //

          for (let i = 0; i < cubeMeshArray.length; i++) {

              let currentX = cubeMeshArray[i].position.x = -(positions[i][0] -185);
              let currentY = cubeMeshArray[i].position.y = -(positions[i][1] -155);

              numberContextArray[i].fillText(i, 0, 120);
              numberMeshArray[i].position.set(-(positions[i][0] -185), -(positions[i][1] -155), -5);
              numberTextureArray[i].needsUpdate = true;
              numberMeshArray[i].geometry.__dirtyVertices = true;

  				}

          TWEEN.update();
          controls.update();
          renderer.render( scene, camera );

        }

        function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth, window.innerHeight );
        }

      </script>

		</div>
    <canvas width="11px" height="781px" id="renderCanvas" style="display:none;"></canvas>


    <!-- draw vertices -->



</body>
</html>