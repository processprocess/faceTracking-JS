<!DOCTYPE html>
<html lang="en">
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>FaceTrackerTest</title>
	</head>
    <link rel="stylesheet" href="styles/styles.css" media="screen" title="no title">
	<body>
		<script src="./libs/utils.js"></script>
		<script src="./libs/clmtrackr.js"></script>
		<script src="./libs/model_pca_20_svm.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js"></script>
    <script src="https://threejs.org/build/three.min.js"> </script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
      <h2>FACE_LAB</h2>

        <video id="video" width="368" height="288" autoplay="" loop=""></video>
        <!-- <video id="video" width="360" height="200" autoplay="" loop=""></video> -->

        <!-- 175 125
        368 288 -->

        <div id="canvasForThree"></div>

      <!-- </div> -->

      <script>

				let videoInput = document.getElementById('video');

        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;

        if (navigator.getUserMedia) {
            navigator.getUserMedia({video: true}, handleVideo, videoError);
        }

        function handleVideo(stream) {
            video.src = window.URL.createObjectURL(stream);
        }

        function videoError(e) {
            console.log('there was an error');
        }

        let ctracker = new clm.tracker();
        ctracker.init(pModel);
        ctracker.start(videoInput);

        //

        let scene, renderer, camera;

        let triangleMesh;
        let squareMesh;

        let faceLine;

        let chinLine;
        let rightEyeBrowLine;

        // let roundRect;

        let lineMesh;

        // let cubeMesh;
        let cubeMeshArray = [];
        let lineMeshArray = [];

        var numberContextArray = [];
        var numberMeshArray = [];
        var numberTextureArray = [];

        // let bottomLipGeometry;
        // let topLipGeometry;
        // let noseGeometry;
        // let noseLineGeometry;
        // let leftEyeGeometry;
        // let rightEyeGeometry;
        // let leftEyeBrowGeometry;

        begin();
        animate();


        function begin(){


          // scene.add(shape)

          // setInterval(function() {
          //   console.log('test');
          // }, 1000);

          camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
          camera.position.z = 200;

          scene = new THREE.Scene();

          let light = new THREE.PointLight(0xffffff);
          light.position.set( -100, 200, 100 );
          scene.add( light );

          let threeContainer = document.getElementById( 'canvasForThree' );

          renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setPixelRatio( window.devicePixelRatio );
          renderer.setSize( window.innerWidth, window.innerHeight );
          threeContainer.appendChild( renderer.domElement );
          renderer.setClearColor( 0xFFFFFF, 1);
          // renderer.setClearColor( 0x333F47, 0.4);

          controls = new THREE.OrbitControls( camera, renderer.domElement );
          controls.enablePan = true;
          controls.enableZoom = true;
          controls.enableRotate = true;
          controls.enableDamping = true;

          window.addEventListener( 'resize', onWindowResize, false );

          // let lineMaterial = new THREE.LineBasicMaterial({
          // 	color: 0x0000ff
          // });

          // let chinGeometry = new THREE.Geometry();
          // for (let i = 0; i<15; i++) {
          //   chinGeometry.vertices.push(
          //   	new THREE.Vector3( 0, 0, 0 )
          //   );
          // }
          // chinLine = new THREE.Line( chinGeometry, lineMaterial );
          // scene.add( chinLine );


          let faceContainerGeometry = new THREE.BoxGeometry(2,2,2);
          let faceContainerMaterial = new THREE.MeshLambertMaterial({
            color: 0xFF0000
          });
          let faceContainerMesh = new THREE.Mesh( faceContainerGeometry, faceContainerMaterial );

          let cubeGeometry = new THREE.BoxGeometry(2,2,2);
          let cubeMaterial = new THREE.MeshLambertMaterial({
            color: 0x0000FF
          });

          for (var i = 0; i < 71; i++) {
  					let cubeMesh = new THREE.Mesh( cubeGeometry, cubeMaterial );
            cubeMeshArray.push( cubeMesh );
            faceContainerMesh.add( cubeMesh );
  				}
          faceContainerMesh.position.set(0, 0, 0);
          scene.add( faceContainerMesh );

          //

          let lineGeometry = new THREE.Geometry();

          let lineMaterial = new THREE.LineBasicMaterial({
            color: 0x0000ff
          });
          // for(i=0; i<200; i++){
            // lineGeometry.vertices.push(
            // 	new THREE.Vector3( 0, 0, 0 ),
            // 	new THREE.Vector3( 50, 50, 0 )
            // );
          // }

          lineMesh = new THREE.Line( lineGeometry, lineMaterial );
          scene.add( lineMesh );

          // for (var i = 0; i < 100; i++) {
          //   var lineMesh = new THREE.Line( lineGeometry, lineMaterial );
          //     lineMesh.geometry.vertices.push(
          //     	// new THREE.Vector3( 0, 0, 0 ),
          //       new THREE.Vector3( 0, 0, 0 )
          //     );
          //   lineMeshArray.push( lineMesh );
          // }
          // faceContainerMesh.add( lineMesh );
          // // chinLine = new THREE.Line( chinGeometry, lineMaterial );
          // // scene.add( chinLine );

          for(let i = 0; i<71; i++){
            var numberCanvas = document.createElement('canvas');
            numberCanvas.width = 256;
            numberCanvas.height = 128;
            let numberContext = numberCanvas.getContext('2d');
            numberContext.font = "90px Arial";
            numberContextArray.push( numberContext )

            let numberTexture = new THREE.Texture(numberCanvas)
            numberTexture.width = 10;
            numberTexture.height = 128;
            numberTextureArray.push( numberTexture )

            var textMaterial = new THREE.MeshBasicMaterial({ map: numberTexture });
            textMaterial.transparent = true;

            let mesh1 = new THREE.Mesh(
                new THREE.PlaneGeometry(10, 5),
                textMaterial
              );
            numberMeshArray.push( mesh1 )
            scene.add( mesh1 )
          }
        }

        function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth, window.innerHeight );
        }






        function animate() {
          let positions = ctracker.getCurrentPosition();
          // setInterval(function() {
          //   console.log('test');
          // }, 1000);

          requestAnimationFrame( animate );
          TWEEN.update();

            // for(let i = 0; i < 40; i++) {
            //   if(i%2 === 0) {
            //     lineMesh.geometry.vertices[i] = {x: -(positions[0][0] -185), y: -(positions[0][1] -155), z: 0};;
            //   } else {
            //     lineMesh.geometry.vertices[i] = {x: -(positions[i][0] -185), y: -(positions[i][1] -155), z: 0};
            //   }
            // }
            // console.log(lineMesh.geometry.vertices.length);
          // lineMesh.geometry.verticesNeedUpdate = true;
          // console.log(lineMesh.geometry);

          for (let i = 0; i < cubeMeshArray.length; i++) {

              let currentX = cubeMeshArray[i].position.x = -(positions[i][0] -185);
              let currentY = cubeMeshArray[i].position.y = -(positions[i][1] -155);

              numberContextArray[i].fillText(i, 0, 120);
              numberMeshArray[i].position.set(-(positions[i][0] -185), -(positions[i][1] -155), -5);
              numberTextureArray[i].needsUpdate = true;

              // run through each point and draw a line for each
              // console.log(lineMesh.geometry.vertices.length);
              // console.log(lineMesh.geometry.vertices[i].x);
              // console.log(lineMesh.geometry.vertices[i].y);
              // lineMeshArray[i].geometry.vertices[0] = currentX;
              // lineMeshArray[i].geometry.vertices[1] = currentY;
              // for (let i = 0; i < positions.length; i += 1) {
              //   lineMesh.geometry.vertices[i].x = - (positions[i][0] -185);
              //   lineMesh.geometry.vertices[i].y = - (positions[i][1] -155);;
              // }

              // for (let i = 0; i < lineMesh.geometry.vertices.length; i++) {
                // console.log(lineMeshArray[i].geometry.vertices);
                // lineMeshArray.vertices.push(
                // 	new THREE.Vector3( 0, 0, 0 )
                // );
              // }
              // lineMeshArray[i].geometry.verticesNeedUpdate = true;
  				}

          // for (let p = 0; p < 17; p++) {
          //   if(p < 15){
          //     chinLine.geometry.vertices[ p ].x = positions[p][0];
          //     chinLine.geometry.vertices[ p ].y = positions[p][1];
          //   }
          //   if(p > 15){
          //     // rightEyeBrowLine.geometry.vertices[ p ].x = positions[p][0];
          //     // rightEyeBrowLine.geometry.vertices[ p ].y = positions[p][1];
          //   }
          //   // if(p > 15){
          // }
          // chinLine.geometry.verticesNeedUpdate = true;
          // rightEyeBrowLine.geometry.verticesNeedUpdate = true;
          //
          // // geometry.attributes.position.needsUpdate = true; // use this for buffer geometry

          // cc.clearRect(0, 0, canvasInput.width, canvasInput.height);
          // ctracker.draw( canvasInput );

          controls.update();
          renderer.render( scene, camera );

        }
        // smoothOutAnimation();
      </script>

		</div>
    <canvas width="11px" height="781px" id="renderCanvas" style="display:none;"></canvas>


    <!-- draw vertices -->



</body>
</html>