<!DOCTYPE html>
<html lang="en">
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>FaceTrackerTest</title>
	</head>
    <link rel="stylesheet" href="styles/styles.css" media="screen" title="no title">
	<body>
		<script src="./libs/utils.js"></script>
		<script src="./libs/clmtrackr.js"></script>
		<script src="./libs/model_pca_20_svm.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js"></script>
    <script src="https://threejs.org/build/three.min.js"> </script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
      <h2>FACE_LAB</h2>

        <video id="video" width="368" height="288" autoplay="" loop=""></video>
        <!-- <video id="video" width="360" height="200" autoplay="" loop=""></video> -->

        <!-- 175 125
        368 288 -->

        <div id="canvasForThree"></div>

      <!-- </div> -->

      <script>

				let videoInput = document.getElementById('video');

        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;

        if (navigator.getUserMedia) {
            navigator.getUserMedia({video: true}, handleVideo, videoError);
        }

        function handleVideo(stream) {
            video.src = window.URL.createObjectURL(stream);
        }

        function videoError(e) {
            console.log('there was an error');
        }

        let ctracker = new clm.tracker();
        ctracker.init(pModel);
        ctracker.start(videoInput);

        //

        let scene, renderer, camera;

        let squareMesh;
        let triangleGeometry;

        let triangleMesh;

        let faceLine;

        let chinLine;
        let rightEyeBrowLine;

        // let roundRect;

        let lineMesh;

        // let cubeMesh;
        let cubeMeshArray = [];
        let lineMeshArray = [];

        var numberContextArray = [];
        var numberMeshArray = [];
        var numberTextureArray = [];

        let testMesh;

        // let bottomLipGeometry;
        // let topLipGeometry;
        // let noseGeometry;
        // let noseLineGeometry;
        // let leftEyeGeometry;
        // let rightEyeGeometry;
        // let leftEyeBrowGeometry;

        begin();
        animate();


        function begin(){


          // scene.add(shape)

          // setInterval(function() {
          //   console.log('test');
          // }, 1000);

          camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
          camera.position.z = 200;

          scene = new THREE.Scene();

          let light = new THREE.PointLight(0xffffff);
          light.position.set( -100, 200, 100 );
          scene.add( light );

          let threeContainer = document.getElementById( 'canvasForThree' );

          renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setPixelRatio( window.devicePixelRatio );
          renderer.setSize( window.innerWidth, window.innerHeight );
          threeContainer.appendChild( renderer.domElement );
          renderer.setClearColor( 0xFFFFFF, 1);
          // renderer.setClearColor( 0x333F47, 0.4);

          controls = new THREE.OrbitControls( camera, renderer.domElement );
          controls.enablePan = true;
          controls.enableZoom = true;
          controls.enableRotate = true;
          controls.enableDamping = true;

          window.addEventListener( 'resize', onWindowResize, false );

          // let lineMaterial = new THREE.LineBasicMaterial({
          // 	color: 0x0000ff
          // });

          // let chinGeometry = new THREE.Geometry();
          // for (let i = 0; i<15; i++) {
          //   chinGeometry.vertices.push(
          //   	new THREE.Vector3( 0, 0, 0 )
          //   );
          // }
          // chinLine = new THREE.Line( chinGeometry, lineMaterial );
          // scene.add( chinLine );


          let faceContainerGeometry = new THREE.BoxGeometry(2,2,2);
          let faceContainerMaterial = new THREE.MeshLambertMaterial({
            color: 0xFF0000
          });
          let faceContainerMesh = new THREE.Mesh( faceContainerGeometry, faceContainerMaterial );

          let cubeGeometry = new THREE.BoxGeometry(2,2,2);
          let cubeMaterial = new THREE.MeshLambertMaterial({
            color: 0x0000FF
          });

          for (var i = 0; i < 71; i++) {
  					let cubeMesh = new THREE.Mesh( cubeGeometry, cubeMaterial );
            cubeMeshArray.push( cubeMesh );
            faceContainerMesh.add( cubeMesh );
  				}
          faceContainerMesh.position.set(0, 0, 0);
          scene.add( faceContainerMesh );

          //

          let lineGeometry = new THREE.Geometry();

          let lineMaterial = new THREE.LineBasicMaterial({
            color: 0x0000ff
          });
          // for(i=0; i<200; i++){
            // lineGeometry.vertices.push(
            // 	new THREE.Vector3( 0, 0, 0 ),
            // 	new THREE.Vector3( 50, 50, 0 )
            // );
          // }

          lineMesh = new THREE.Line( lineGeometry, lineMaterial );
          scene.add( lineMesh );

          // for (var i = 0; i < 100; i++) {
          //   var lineMesh = new THREE.Line( lineGeometry, lineMaterial );
          //     lineMesh.geometry.vertices.push(
          //     	// new THREE.Vector3( 0, 0, 0 ),
          //       new THREE.Vector3( 0, 0, 0 )
          //     );
          //   lineMeshArray.push( lineMesh );
          // }
          // faceContainerMesh.add( lineMesh );
          // // chinLine = new THREE.Line( chinGeometry, lineMaterial );
          // // scene.add( chinLine );

          for(let i = 0; i<71; i++){
            var numberCanvas = document.createElement('canvas');
            numberCanvas.width = 256;
            numberCanvas.height = 128;
            let numberContext = numberCanvas.getContext('2d');
            numberContext.font = "90px Arial";
            numberContextArray.push( numberContext )

            let numberTexture = new THREE.Texture(numberCanvas)
            numberTexture.width = 10;
            numberTexture.height = 128;
            numberTextureArray.push( numberTexture )

            var textMaterial = new THREE.MeshBasicMaterial({ map: numberTexture });
            textMaterial.transparent = true;

            let mesh1 = new THREE.Mesh(
                new THREE.PlaneGeometry(10, 5),
                textMaterial
              );
            numberMeshArray.push( mesh1 )
            scene.add( mesh1 )
          }


          // let lineGeometry = new THREE.Geometry();
          //
          // let lineMaterial = new THREE.LineBasicMaterial({
          //   color: 0x0000ff
          // });
          //
          // lineMesh = new THREE.Line( lineGeometry, lineMaterial );
          // scene.add( lineMesh );


          // 35 44 2

          triangleGeometry = new THREE.Geometry();
          triangleGeometry.vertices.push(new THREE.Vector3( 0.0, 10.0, 0.0 ));
          triangleGeometry.vertices.push(new THREE.Vector3( -10.0, -10.0, 0.0 ));
          triangleGeometry.vertices.push(new THREE.Vector3( 10.0, -10.0, 0.0 ));
          triangleGeometry.faces.push(new THREE.Face3( 0, 1, 2 ));
          // triangleGeometry.dynamic = true;
          // triangleGeometry.verticesNeedUpdate = true;
          // triangleGeometry.__dirtyVertices = true;

          // triangleGeometry.faces[0].vertexColors[0] = new THREE.Color( 0xFF0000 );
          // triangleGeometry.faces[0].vertexColors[1] = new THREE.Color( 0x00FF00 );
          // triangleGeometry.faces[0].vertexColors[2] = new THREE.Color( 0x0000FF );

          // let triangleMaterial = new THREE.LineBasicMaterial({
          let triangleMaterial = new THREE.MeshBasicMaterial({
            color: 0x0000FF,
            // vertexColors: THREE.VertexColors,
            side: THREE.DoubleSide
            // wireframe: true
          });

          // triangleMesh = new THREE.Line( triangleGeometry, triangleMaterial );
          triangleMesh = new THREE.Mesh( triangleGeometry, triangleMaterial );
          scene.add( triangleMesh );
          // triangleMesh.position.set( 0, 0, 0 );
          // triangleMesh.geometry.verticesNeedUpdate = true;
          // triangleMesh.geometry.matrixWorldNeedsUpdate = true;
          // triangleMesh.geometry.dynamic = true;

          //

          // let testGeometry = new THREE.Geometry();
          // testGeometry.vertices.push(new THREE.Vector3( 0.0, 10.0, 0.0 ));
          // testGeometry.vertices.push(new THREE.Vector3( 10.0, 10.0, 0.0 ));
          // testGeometry.vertices.push(new THREE.Vector3( 0.0, 10.0, 10.0 ));
          // testGeometry.faces.push(new THREE.Face3( 0, 1, 2 ));
          // testMesh

        }

        function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth, window.innerHeight );
        }






        function animate() {
          let positions = ctracker.getCurrentPosition();
          // setInterval(function() {
          //   console.log('test');
          // }, 1000);

          requestAnimationFrame( animate );

          // lineMesh.geometry.vertices[0] = {x: -(positions[44][0] -185), y: -(positions[44][1] -155), z: -5 }
          // lineMesh.geometry.vertices[1] = {x: -(positions[35][0] -185), y: -(positions[35][1] -155), z: -5 }
          // lineMesh.geometry.vertices[2] = {x: -(positions[2][0] -185), y: -(positions[2][1] -155), z: -5 }
          // triangleMesh.geometry.__dirtyVertices = true;
          // triangleMesh.geometry.verticesNeedUpdate = true;
          // triangleMesh.geometry.dynamic = true;

          //

          console.log(triangleMesh.geometry.vertices[0].set);

          triangleMesh.geometry.vertices[0].set(-(positions[35][0] -185), -(positions[35][1] -155), -5);
          triangleMesh.geometry.vertices[1].set(-(positions[44][0] -185), -(positions[44][1] -155), -5);
          triangleMesh.geometry.vertices[2].set(-(positions[2][0] -185), -(positions[2][1] -155), -5);
          // triangleMesh.geometry.vertices[2] = {x: -(positions[2][0] -185), y: -(positions[2][1] -155), z: -5 }
          // triangleMesh.geometry.__dirtyVertices = true;
          triangleMesh.geometry.verticesNeedUpdate = true;
          // triangleMesh.geometry.dynamic = true;

          //

          // for(let i = 0; i < 40; i++) {
          //   if(i%2 === 0) {
          //     lineMesh.geometry.vertices[i] = {x: -(positions[0][0] -185), y: -(positions[0][1] -155), z: 0};;
          //   } else {
          //     lineMesh.geometry.vertices[i] = {x: -(positions[i][0] -185), y: -(positions[i][1] -155), z: 0};
          //   }
          // }
          lineMesh.geometry.verticesNeedUpdate = true;
          // lineMesh.geometry.__dirtyVertices = true;

          //

          for (let i = 0; i < cubeMeshArray.length; i++) {

              let currentX = cubeMeshArray[i].position.x = -(positions[i][0] -185);
              let currentY = cubeMeshArray[i].position.y = -(positions[i][1] -155);

              numberContextArray[i].fillText(i, 0, 120);
              numberMeshArray[i].position.set(-(positions[i][0] -185), -(positions[i][1] -155), -5);
              numberTextureArray[i].needsUpdate = true;

  				}


          // for (let p = 0; p < 17; p++) {
          //   if(p < 15){
          //     chinLine.geometry.vertices[ p ].x = positions[p][0];
          //     chinLine.geometry.vertices[ p ].y = positions[p][1];
          //   }
          //   if(p > 15){
          //     // rightEyeBrowLine.geometry.vertices[ p ].x = positions[p][0];
          //     // rightEyeBrowLine.geometry.vertices[ p ].y = positions[p][1];
          //   }
          //   // if(p > 15){
          // }
          // chinLine.geometry.verticesNeedUpdate = true;
          // rightEyeBrowLine.geometry.verticesNeedUpdate = true;
          //
          // // geometry.attributes.position.needsUpdate = true; // use this for buffer geometry

          // cc.clearRect(0, 0, canvasInput.width, canvasInput.height);
          // ctracker.draw( canvasInput );

          TWEEN.update();
          controls.update();
          renderer.render( scene, camera );

        }
        // smoothOutAnimation();
      </script>

		</div>
    <canvas width="11px" height="781px" id="renderCanvas" style="display:none;"></canvas>


    <!-- draw vertices -->



</body>
</html>