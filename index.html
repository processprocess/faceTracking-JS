<!DOCTYPE html>
<html lang="en">
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>FaceTrackerTest</title>

		<style>
      html, body { margin: 0; padding: 0; overflow: hidden; font-family: inconsolata;}

      /*#canvasForTracker {
        position : absolute;
        left : 0;
        top : 0;
      }*/

      h2 {
        /*text-align: center;*/
        /*float: right;*/
        position: absolute;
        top:0;
        bottom: 0;
        left: 0;
        right: 0;
        margin: auto;
      }

      #content {
        text-align: center;
        margin: 0, auto;
        padding: 0;
        overflow: hidden;
        /*float: left; */
        /*position: absolute;*/
      }

      #video{
        /*width:100px;
        height:100px;*/
        opacity: .04;
        position: absolute;
        top:0;
        bottom: 0;
        left: 0;
        right: 0;

        /*margin: auto;*/
      }

      #testingDiv{
        font-size: 100px;
        color:red;
        /*width:200px;
        height:200px;*/
        opacity: .04;
        background-color: red;
        /*position: absolute;*/
        /*top:0;
        bottom: 0;
        left: 0;
        right: 0;*/

        /*margin: auto;*/
      }

      #canvasForThree {
          /*background-color: blue;*/
          /*opacity:1;*/
          /*width: 360px;
          height: 200px;*/
          /*border: 1px solid black;*/
          /*margin: 100px;*/
          /*padding: 0px;*/
          /*position: fixed; /* fixed or static */*/
          /*top: 100px;*/
          /*left: 100px;*/
      }

		</style>
	</head>

	<body>
		<script src="./libs/utils.js"></script>
		<script src="./libs/clmtrackr.js"></script>
		<script src="./libs/model_pca_20_svm.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js"></script>
    <script src="https://threejs.org/build/three.min.js"> </script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
      <h2>FACE_LAB</h2>

        <video id="video" width="368" height="288" autoplay="" loop=""></video>
        <!-- <video id="video" width="360" height="200" autoplay="" loop=""></video> -->

        <!-- 175 125
        368 288 -->

        <div id="canvasForThree"></div>

      <!-- </div> -->

      <script>

				let videoInput = document.getElementById('video');

        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;

        if (navigator.getUserMedia) {
            navigator.getUserMedia({video: true}, handleVideo, videoError);
        }

        function handleVideo(stream) {
            video.src = window.URL.createObjectURL(stream);
        }

        function videoError(e) {
            console.log('there was an error');
        }

        let ctracker = new clm.tracker();
        ctracker.init(pModel);
        ctracker.start(videoInput);

        //

        let scene, renderer, camera;

        let triangleMesh;
        let squareMesh;

        let faceLine;

        let chinLine;
        let rightEyeBrowLine;

        let lineMesh;

        // let cubeMesh;
        let cubeMeshArray = [];
        let lineMeshArray = [];

        // let bottomLipGeometry;
        // let topLipGeometry;
        // let noseGeometry;
        // let noseLineGeometry;
        // let leftEyeGeometry;
        // let rightEyeGeometry;
        // let leftEyeBrowGeometry;

        begin();
        animate();



        function begin(){

          // setInterval(function() {
          //   console.log('test');
          // }, 1000);

          camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
          camera.position.z = 200;

          scene = new THREE.Scene();

          let light = new THREE.PointLight(0xffffff);
          light.position.set( -100, 200, 100 );
          scene.add( light );

          let threeContainer = document.getElementById( 'canvasForThree' );
          // threeContainer.innerHTML = 'test';

          renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setPixelRatio( window.devicePixelRatio );
          renderer.setSize( window.innerWidth, window.innerHeight );
          threeContainer.appendChild( renderer.domElement );
          renderer.setClearColor( 0xFFFFFF, 1);
          // renderer.setClearColor( 0x333F47, 0.4);



          // videoInput.width = renderer.domElement.clientWidth;
          // videoInput.width = 230;
          // videoInput.height = renderer.domElement.clientHeight;
          // videoInput.height = 300;

          controls = new THREE.OrbitControls( camera, renderer.domElement );
          controls.enablePan = true;
          controls.enableZoom = true;
          controls.enableRotate = true;
          controls.enableDamping = true;

          window.addEventListener( 'resize', onWindowResize, false );

          // let lineMaterial = new THREE.LineBasicMaterial({
          // 	color: 0x0000ff
          // });

          // let chinGeometry = new THREE.Geometry();
          // for (let i = 0; i<15; i++) {
          //   chinGeometry.vertices.push(
          //   	new THREE.Vector3( 0, 0, 0 )
          //   );
          // }
          // chinLine = new THREE.Line( chinGeometry, lineMaterial );
          // scene.add( chinLine );

          let cubeGeometry = new THREE.BoxGeometry(2,2,2);

          let cubeMaterial = new THREE.MeshLambertMaterial({
            color: 0x0000FF
          });

          let faceContainerGeometry = new THREE.BoxGeometry(2,2,2);
          let faceContainerMaterial = new THREE.MeshLambertMaterial({
            color: 0xFF0000
          });
          let faceContainerMesh = new THREE.Mesh( faceContainerGeometry, faceContainerMaterial );

          for (var i = 0; i < 71; i++) {
  					let cubeMesh = new THREE.Mesh( cubeGeometry, cubeMaterial );
  					cubeMeshArray.push( cubeMesh );
            faceContainerMesh.add( cubeMesh );
  				}
          faceContainerMesh.position.set(0, 0, 0);
          scene.add( faceContainerMesh );

          //

          let lineGeometry = new THREE.Geometry();

          let lineMaterial = new THREE.LineBasicMaterial({
            color: 0x0000ff
          });

            lineGeometry.vertices.push(
            	new THREE.Vector3( 0, 0, 0 ),
            	new THREE.Vector3( 100, 100, 0 )
            );

          lineMesh = new THREE.Line( lineGeometry, lineMaterial );
          scene.add( lineMesh );

          // console.log(lineMesh.geometry.vertices[0]);
          // lineMesh.geometry.vertices[0] = {x: 100, y: 30, z: 0}
          // lineMesh.geometry.vertices[1] = {x: 100, y: 30, z: 0}
          // console.log(lineMesh.geometry.vertices[0]);


          // at this to the update function
          // iterate over this
          // set next item to equal amount

          // for (var i = 0; i < 100; i++) {
          //   var lineMesh = new THREE.Line( lineGeometry, lineMaterial );
          //     lineMesh.geometry.vertices.push(
          //     	// new THREE.Vector3( 0, 0, 0 ),
          //       new THREE.Vector3( 0, 0, 0 )
          //     );
          //   lineMeshArray.push( lineMesh );
          // }
          // faceContainerMesh.add( lineMesh );
          // // chinLine = new THREE.Line( chinGeometry, lineMaterial );
          // // scene.add( chinLine );

        }


        // copy last position of geometry
        // animate fade out and removal from screen


        function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth, window.innerHeight );
        }

        // function getPositionGlobal() {
        //   let positions = ctracker.getCurrentPosition();
        //   return positions;
        // }

        function animate() {

          // getPositionGlobal();

          let positions = ctracker.getCurrentPosition();




          // setInterval(function() {
          //   console.log('test');
          // }, 1000);

          // console.log(video.width);
          requestAnimationFrame( animate );
          TWEEN.update();

          // let positions = ctracker.getCurrentPosition();

          // console.log(lineMesh.geometry.vertices[0]);
          lineMesh.geometry.vertices[0] = {x: positions[0][0], y: 20, z: 0}
          lineMesh.geometry.vertices[1] = {x: 200, y: 200, z: 0}
          // lineMesh.geometry.vertices[0] = {x: positions[0][0], y: positions[0][1], z: 0}
          // lineMesh.geometry.vertices[1] = {x: positions[1][1], y: positions[1][2], z: 0}
          console.log(lineMesh.geometry.vertices[0]);
          // console.log(positions[0][0]);
          // console.log(positions[i][0]);
          // lineMesh.geometry.verticesNeedUpdate = true;
          lineMesh.geometry.verticesNeedupdate = true;

          for (let i = 0; i < cubeMeshArray.length; i++) {
            // console.log(lineMesh.geometry.vertices[1]);
            // console.log(positions[0][0]);
              let currentX = cubeMeshArray[i].position.x = - (positions[i][0] -185);
              let currentY = cubeMeshArray[i].position.y = - (positions[i][1] -155);
              // run through each point and draw a line for each
              // console.log(lineMesh.geometry.vertices.length);
              // console.log(lineMesh.geometry.vertices[i].x);
              // console.log(lineMesh.geometry.vertices[i].y);
              // lineMeshArray[i].geometry.vertices[0] = currentX;
              // lineMeshArray[i].geometry.vertices[1] = currentY;
              // for (let i = 0; i < positions.length; i += 1) {
              //   lineMesh.geometry.vertices[i].x = - (positions[i][0] -185);
              //   lineMesh.geometry.vertices[i].y = - (positions[i][1] -155);;
              // }

              // for (let i = 0; i < lineMesh.geometry.vertices.length; i++) {
                // console.log(lineMeshArray[i].geometry.vertices);
                // lineMeshArray.vertices.push(
                // 	new THREE.Vector3( 0, 0, 0 )
                // );
              // }
              // lineMeshArray[i].geometry.verticesNeedUpdate = true;
  				}
          // console.log(lineMeshArray[0].geometry.vertices.length);


          // for (let p = 0; p < 17; p++) {
          //   if(p < 15){
          //     chinLine.geometry.vertices[ p ].x = positions[p][0];
          //     chinLine.geometry.vertices[ p ].y = positions[p][1];
          //   }
          //   if(p > 15){
          //     // rightEyeBrowLine.geometry.vertices[ p ].x = positions[p][0];
          //     // rightEyeBrowLine.geometry.vertices[ p ].y = positions[p][1];
          //   }
          //   // if(p > 15){
          // }
          // chinLine.geometry.verticesNeedUpdate = true;
          // rightEyeBrowLine.geometry.verticesNeedUpdate = true;
          //
          // // geometry.attributes.position.needsUpdate = true; // use this for buffer geometry

          // cc.clearRect(0, 0, canvasInput.width, canvasInput.height);
          // ctracker.draw( canvasInput );

          controls.update();
          renderer.render( scene, camera );

        }
        // smoothOutAnimation();
      </script>

		</div>
    <canvas width="11px" height="781px" id="renderCanvas" style="display:none;"></canvas>

<!-- make face bigger -->
<!-- make those vectors -->

<!-- choose two points in the array and draw a line -->
<!-- choose random points from array -->
<!-- get first vertext -->
<!-- make more lines from that vertex, to another -->




</body>
</html>